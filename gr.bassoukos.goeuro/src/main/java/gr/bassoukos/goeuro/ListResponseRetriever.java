package gr.bassoukos.goeuro;

import gr.bassoukos.goeuro.om.ErrorResponse;

import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;

/**
 * Search remote API that responds with an array of objects (possibly
 * zero-length), or with an error response. Instances of this class are
 * configured with a target URL, to which the search term gets appended, a
 * connection is made and the objects are unmarshalled.
 * 
 * @param <T>
 *            the type of objects that this retriever should produce.
 * @author abas
 */
public class ListResponseRetriever<T> {
	/**
	 * Handle retrieved objects. Should be replaced when using 1.8 by Consumer.
	 * 
	 * @author abas
	 *
	 * @param <T>
	 *            What kind of objects are being collected - this needs to match
	 *            the retriever.
	 */
	public static interface Handler<T> {
		public void handle(T t) throws IOException;
	}

	/******************************/
	/**
	 * The target base URL
	 */
	private URL target;

	/**
	 * The class of the objects returned by this instance.
	 */
	private Class<T> klass;

	/**
	 * Contruct an instance for the specified class and target.
	 * 
	 * @param klass
	 *            the class of objects that the target URL corresponds to
	 * @param target
	 *            the target URL
	 * @throws MalformedURLException
	 *             if the target URL is malformed
	 */
	public ListResponseRetriever(Class<T> klass, String target)
			throws MalformedURLException {
		this(klass, new URL(target));
	}

	/**
	 * Construct an instance for the specified class and target.
	 * 
	 * @param klass
	 *            the class of objects that the target URL corresponds to
	 * @param target
	 *            the target URL
	 */
	public ListResponseRetriever(Class<T> klass, URL target) {
		this.klass = klass;
		this.target = target;
	}

	/**
	 * Set the target URL.
	 * 
	 * @param target
	 *            the new target
	 * @return the same instance
	 */
	public ListResponseRetriever<T> targeting(URL target) {
		this.target = target;
		return this;
	}

	/**
	 * Send a request to the server and return all collected objects in a List.
	 * 
	 * @param searchTerm
	 *            the search term to use for the suggestions.
	 * @return the suggested positions generated by the server.
	 * @throws ErrorResponse
	 *             if the server responded with an error
	 * @throws IOException
	 *             if a connection problem occured.
	 */
	public List<T> search(String searchTerm) throws ErrorResponse, IOException {
		final ArrayList<T> results = new ArrayList<>();
		search(searchTerm, new Handler<T>() {
			@Override
			public void handle(T t) {
				results.add(t);
			}
		});
		return results;
	}

	/**
	 * Send a request to the server, and pass each one of the returned objects
	 * to the handler.
	 * 
	 * @param searchTerm
	 *            the search term to use.
	 * @param handler
	 *            how to handle each new object sent by the server.
	 * @return the suggested positions generated by the server.
	 * @throws ErrorResponse
	 *             if the server responded with an error
	 * @throws IOException
	 *             if a connection problem occured.
	 */
	public void search(String searchTerm, Handler<T> handler)
			throws ErrorResponse, IOException {
		URL url = new URL(target, URLEncoder.encode(searchTerm, "UTF-8"));
		Gson gson = new Gson();
		try (JsonReader reader = new JsonReader(new InputStreamReader(
				url.openStream(), "UTF-8"))) {
			// if the object isn't an array, response is an ErrorResponse -
			// get it and throw it.
			if (!reader.peek().equals(JsonToken.BEGIN_ARRAY)) {
				// interesting, type inference won't work without the local
				// variable declaration.
				ErrorResponse e = gson.fromJson(reader, ErrorResponse.class);
				throw e;
			}

			reader.beginArray();
			while (reader.hasNext()) {
				T pos = gson.fromJson(reader, klass);
				handler.handle(pos);
			}
			reader.endArray();
		}
	}
}
